## 컴포넌트란?

컴포넌트는 배포 단위입니다. **컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위**입니다. 자바의 경우 jar 파일이 컴포넌트입니다. 루비에서는 gem, 닷넷에서는 DLL입니다. 컴파일형 언어에서 컴포넌트는 바이너리 파일의 결합체입니다. 인터프리터형 언어의 경우는 소스 파일의 결합체입니다. 모든 언어에서 컴포넌트는 배포할 수 있는 단위 입자입니다.

## 컴포넌트 응집도

그렇다면 어떤 클래스를 어느 컴포넌트에 포함시켜야할까요? 이는 중요한 결정이므로, 제대로 된 소프트웨어 엔지니어링 원칙의 도움을 받아야 합니다. 그 원칙으로는 아래의 세 가지 원칙이 있습니다.

-   REP : 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)
    
-   CCP : 공통 폐쇄 원칙 (Common Closure Principle)
    
-   CRP : 공통 재사용 원칙 (Common Reuse Principle)
    
    다음으로 위 세 가지 원칙에 대해서 알아보겠습니다.
    

### REP : 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)

재사용 단위는 릴리스 단위와 같다.

우리는 소프트웨어 재사용의 시대에 살고 있습니다. 그렇기 때문에 소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수도 없고, 하지도 않을 것입니다. 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없기 때문입니다. 하지만 이 단순한 이유 말고도 다른 이유가 있는데, 새로운 버전이 언제 출시되고 무엇이 변했는지를 소프트웨어 개발자들이 알아야 하기 때문입니다.

새로운 릴리스가 나온다는 소식을 접하면, 개발자는 새 릴리스의 변경 사항을 살펴보고 기존 버전을 계속 쓸지 여부를 결정하곤 합니다. 따라서 릴리스 절차에는 적절한 공지와 함께 릴리스 문서 작성도 포함되어야 합니다. 그래야 개발자들이 충분한 정보를 바탕으로 새 릴리스를 통합할지, 한다면 언제 할지 결정할 수 있게됩니다.

**이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈로 구성되어야 함을 뜻합니다.**

하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스 할 수 있어야 합니다. 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 합니다.

### CCP : 공통 폐쇄 원칙 (Common Closure Principle)

**동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어야 하고, 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리해야 한다는 원칙입니다.** 이 원칙은 **단일 책임 원칙(SRP)을 컴포넌트의 관점에서 다시 정의한 것**입니다. SRP에서 단일 클래스는 변경의 이유가 여러 개 있어서는 안 된다고 말하듯이, CCP에서도 마찬가지로 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다고 이야기 합니다.

대다수의 애플리케이션에서 유지보수성(maintainability)은 재사용성보다 훨씬 중요합니다. 애플리케이션의 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫습니다. 만약 변경을 단일 컴포넌트로 제한할 수 있다면, 해당 컴포넌트만 재배포하면 됩니다. 변경된 컴포넌트에 의존하지 않는 다른 컴포넌트는 다시 검증하거나 배포할 필요가 없습니다.

이 원칙은 개방 폐쇄 원칙(OCP)과도 밀접하게 관련되어 있습니다. 실제로 CCP에서 말하는 '폐쇄(Closure)'는 OCP에서 말하는 '폐쇄(Closure)'와 그 뜻이 같습니다. OCP에서는 클래스가 변경에는 닫혀 있고, 확장에는 열려 있어야 한다고 말합니다. 100% 완전한 폐쇄는 불가능하므로 전략적으로 폐쇄해야 합니다.

CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 확대 적용합니다. 따라서 변경이 필요한 요구사항이 발생했을 때, 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아지게 됩니다.

---

## 참고자료

[Clean Architecture](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788966262472&orderClick=LAG&Kc=) <<로버트C. 마틴 지음>>
