# Explain 실행 계획

## explain 명령어

 select문을 어떠한 방식으로 수행하여 데이터를 가져올 것인지에 대한 실행 계획을 출력하는 명령어입니다. 사용 방법은 질의하고자 하는 select 쿼리 앞에 explain 키워드를 붙여서 사용합니다. (ex : explain select \* from table)

![explain](./images/explain.png)

 실행 계획은 아래와 같은 형식으로 표현됩니다. 이제 각 컬럼별로 어떤 의미를 나타내는지 살펴보겠습니다.

## id

 select 쿼리별로 부여되는 식별자 값입니다. 만약 하나의 select 문에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id가 부여됩니다. 하지만 쿼리 문장이 서로 다른 select 문(쿼리 안에 서브쿼리 구성 등..)으로 구성되어 있으면 각 레코드의 id 컬럼이 각기 다른 값을 부여받게 됩니다.

## select\_type

 select 문의 유형을 나타냅니다.

-   SIMPLE
    -   서브쿼리나 UNION이 없는 가장 단순한 형태의 테이블을 말합니다.
-   PRIMARY
    -   가장 바깥의 select문을 말합니다.
-   DERIVED
    -   from 절에 사용된 서브쿼리로부터 발생한 임시 테이블을 말합니다. 임시 테이블은 메모리에 저장될 수도 있고, 디스크에 저장될 수도 있습니다. **일반적으로 메모리에 저장하는 경우에는 성능에 큰 영향을 미치지 않지만, 데이터의 크기가 커서 임시 테이블을 디스크에 저장할 경우 성능이 떨어지게 됩니다.**
-   SUBQUERY
    -   from 절 이외에서 사용되는 서브쿼리를 의미합니다. 서브쿼리는 사용되는 위치에 따라 각각 다른 이름을 가지고 있습니다.
        -   중첩된 쿼리 (Nested Query) : select 되는 컬럼에 사용된 서브쿼리를 말합니다.
        -   서브 쿼리 (Sub Query) : where 절에서 사용된 경우에는 일반적으로 그냥 서브 쿼리라고 말합니다.
        -   파생 테이블 (Derived) : from 절에서 사용된 서브 쿼리를 말합니다.
-   DEPENDENT SUBQUERY
    -   서브 쿼리가 바깥쪽 select 쿼리에서 정의된 컬럼을 사용하는 경우를 말합니다. **이는 서브 쿼리가 먼저 실행되지 못하고 서브 쿼리가 외부 쿼리 결과에 의존적이기 때문에 전체 쿼리의 성능을 느리게 만듭니다.** 서브 쿼리가 외부의 쿼리의 값을 전달받고 있는지 검토해서, 가능하다면 외부 쿼리와의 의존도를 제거하는 것이 좋습니다.
-   UNCACHEABLE SUBQUERY
    -   쿼리의 from 절 이외의 부분에서 사용되는 서브 쿼리는 가능하면 MySQL 옵티마이저가 캐싱하여 최대한 재사용 될 수 있게 유도합니다. 하지만 사용자 변수나 일부 함수가 사용된 경우에는 이러한 캐시 기능을 사용할 수 없게 만듭니다. 이런 실행 계획이 사용된다면 사용자 변수를 제거하거나 다른 함수로 대체해서 사용할 수 있을지 검토해보는 것이 좋습니다.
-   UNION
    -   union으로 결합하는 단위 select 쿼리 가운데 첫 번째를 제외한 두 번째 이후의 단위 select 쿼리의 select\_type은 UNION으로 표시됩니다.
-   DEPENDENT UNION
    -   UNION select\_type과 같지만 union으로 결합된 단위 쿼리가 바깥쪽 쿼리에 의존적이어서 외부의 영향을 받고 있는 경우를 말합니다.

## table

 참조되는 테이블을 말합니다. 테이블 이름에 별칭(Alias)가 부여된 경우에는 별칭이 표시됩니다. table 컬럼이 "<derived>" 또는 "<union>"과 같이 "<>"로 둘러싸인 이름이 명시되는 경우는 임시 테이블이라는 의미입니다. 또한 "<>" 안에 항상 표시되는 숫자는 단위 select 쿼리의 id를 지칭합니다. (ex: <union1, 2>)

## partitions

  테이블이 파티셔닝이 되어있는 경우에 사용되는 필드입니다. 파티셔닝이 되어있지 않으면 null이 출력됩니다.

## type

 테이블의 레코드를 어떤 방식으로 접근했는지에 대한 정보를 나타냅니다. 접근 방식은 대상 테이블로의 접근 방식이 효율적일지 여부를 판단하는데 중요한 항목입니다.

-   system
    -   레코드가 한 건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법을 말합니다. (InnoDB 테이블에서는 나타나지 않습니다.)
-   const
    -   테이블의 레코드 수에 관계없이 Primary key나 Unique key 컬럼을 이용하는 where절 조건을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리방식입니다.
-   eq\_ref
    -   여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시됩니다. Primary key나 Unique key를 사용하여 조인하는 경우를 말합니다. 조인되는 테이블에서 레코드가 반드시 한 건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방식입니다.
-   ref
    -   eq\_ref와 달리 인덱스의 종류와 상관없이 동등 조건으로 검색할 때 사용되는 접근 방식입니다. 반환되는 레코드가 반드시 한 건이라는 보장이 없으므로 eq\_ref 보다는 빠르지 않습니다.
-   ref\_or\_null
    -   ref와 같으면서 null 비교가 추가된 형태의 접근 방식입니다.
-   fulltext
    -   전문검색(FullText) 인덱스를 사용하여 레코드를 읽는 방법을 의미합니다.
-   index\_merge
    -   2개 이상의 인덱스를 이용하여 각각의 검색 결과를 만들어낸 후에 그 결과를 병합하는 처리 방식입니다. (FullText index 제외)
-   unique\_subquery
    -   where 조건절에서 사용할 수 있는 in(subquery) 형태의 쿼리를 위한 접근 방법입니다. 서브 쿼리에서 중복되지 않는 Unique한 결과 값을 반환할 때 이 방법을 사용합니다.
-   index\_subquery
    -   in(subquery) 형태에서 subquery가 중복된 값을 반환할 수는 있지만 인덱스를 이용하여 중복된 값을 제거할 수 있을 때 사용하는 접근 방법입니다.
-   range
    -   주어진 범위 내의 레코드를 스캔하는 형태의 접근 방법입니다. 주로 "<, >, IS NULL, BETWEEN, IN, LIKE" 등의 연산자를 이용하여 인덱스를 검색할 때 사용됩니다.
-   index
    -   전체 인덱스를 처음부터 끝까지 풀 스캔하는 것을 의미합니다. 일반적인 경우 인덱스가 테이블보다 사이즈가 훨씬 작기 때문에 테이블 풀 스캔과 비교했을 때, 읽는 레코드 건 수는 같지만 테이블 풀 스캔보다 빠를 확률이 큽니다.
-   ALL
    -   테이블을 처음부터 끝까지 읽는 테이블 풀 스캔을 의미합니다. 테이블 풀 스캔은 위에서 설명된 타입으로 처리할 수 없을 때 가장 마지막에 선택되며, 대부분의 경우 아주 느린 성능을 보입니다.

---

## 참고자료

[https://denodo1.tistory.com/306](https://denodo1.tistory.com/306)

[https://12bme.tistory.com/168](https://12bme.tistory.com/168)

[https://idea-sketch.tistory.com/48](https://idea-sketch.tistory.com/48)